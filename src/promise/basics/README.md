# Promise
[Promise](https://promisesaplus.com/) is an interface that is implemented natively in ES2015. The promise API allows you to write asynchronous code without descending to the "callback hell" of earlier versions of javascript. While it has been designed as an improvement over past iterations of async code in javascript, it is still easy to misunderstand the library and create code that is hard to read and test. [This article](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) is very comprehensive and I would recommend reading it, along with as much of the actual [promise reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) as you can bear.

To supplement those resources, I've created some examples that I think demonstrate the mechanics of promises. Like the "Using promises" guide, I focus on the consumption of promises. Most programmers will be consuming promises from common libraries like [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API). In this context, manual creation of promises will usually be done in order to leverage Promise's error handling and flow control, and will be accomplished using built-in factory methods intended for that purpose. Think twice before using the Promise constructor.

Each example is started with a promise made from the `resolve` factory method. In real code, this first line would likely be the invocation of a library method to make an http call. Various characteristics of the `then` and `catch` handlers are explored. In many tests, you will see `expect(false).toEqual(true)` or something similar. This is to illustrate that the code path is not expected to be executed in that example. All the tests should pass as written.

These examples are written with jasmine. The basic facility for handling async code in jasmine is to take a parameter `done` in your test, and to invoke that parameter when your async code has finished executing. If you do not call `done` within 5 seconds of the test starting, jasmine will complain. If you are executing async code in a jasmine test and do not provide and invoke `done`, it is unlikely that your expectations are working as expected, or even being executed. There are more clever ways to accomplish this that require less boilerplate (including using a different test framework like mocha), but the intention of these examples is to exhibit the barebones mechanics of promises, not write beautiful code.

When testing promises in jasmine, be sure that your test is executing the handler you think it is. Errors can be masked by `catch` handlers that do not have rigorous expecations, or by `catch` handlers that are not actually executed because the intended error is not occurring. Try to set up your test so that no matter what, an expectation is actually executed. You can also use the global method `fail` provided by jasmine to manually fail a test. The describe block 'some peculiarities with jasmine' has some passing tests which should really be failing tests. See if you can make them fail appropriately.
